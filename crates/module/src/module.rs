pub mod config;
pub mod db;

use std::any::Any;
use std::collections::BTreeMap;
use std::sync::Arc;

use async_trait::async_trait;
use bfte_consensus_core::block::BlockRound;
use bfte_consensus_core::citem::{CItemRaw, InputRaw, OutputRaw};
use bfte_consensus_core::module::{ModuleId, ModuleKind};
use bfte_consensus_core::peer::PeerPubkey;
use bfte_consensus_core::peer_set::PeerSet;
use bfte_consensus_core::ver::{ConsensusVersion, ConsensusVersionMajor, ConsensusVersionMinor};
use bfte_db::Database;
use bfte_db::error::DbTxResult;
use bfte_util_error::Whatever;
use config::ModuleConfig;
use db::{ModuleDatabase, ModuleWriteTransactionCtx};
use derive_more::Deref;
use snafu::Snafu;
use tokio::sync::watch;

use crate::effect::{CItemEffect, ModuleCItemEffect};

#[derive(Deref)]
pub struct DynModuleWithConfig {
    pub config: ModuleConfig,
    #[deref]
    pub inner: DynModule,
}

#[non_exhaustive]
pub struct ModuleInitArgs {
    pub db: ModuleDatabase,
    pub module_consensus_version: ConsensusVersion,
    pub peer_pubkey: Option<PeerPubkey>,
    /// Only AppConsensus module should use this
    #[doc(hidden)]
    pub modules_inits: BTreeMap<ModuleKind, DynModuleInit>,
}

pub type DynModuleInit = Arc<dyn IModuleInit + Send + Sync>;

impl ModuleInitArgs {
    pub fn new(
        module_id: ModuleId,
        db: Arc<Database>,
        module_consensus_version: ConsensusVersion,
        modules_inits: BTreeMap<ModuleKind, DynModuleInit>,
        peer_pubkey: Option<PeerPubkey>,
    ) -> Self {
        Self {
            db: ModuleDatabase::new(module_id, db),
            module_consensus_version,
            peer_pubkey,
            modules_inits,
        }
    }
}

#[derive(Debug, Snafu)]
#[snafu(visibility(pub))]
pub enum ModuleInitError {
    InvalidConfig,
    UnsupportedVersion {
        requested: ConsensusVersion,
        supported: ConsensusVersion,
    },
    Other,
}

pub type ModuleInitResult<T> = Result<T, ModuleInitError>;

pub type ModuleSupportedConsensusVersions = BTreeMap<ConsensusVersionMajor, ConsensusVersionMinor>;

/// Module "constructor"
#[async_trait]
pub trait IModuleInit: Any {
    fn kind(&self) -> ModuleKind;

    /// If true, this module kind can be installed only once in the federation
    fn singleton(&self) -> bool;

    fn display_name(&self) -> &'static str;

    /// All major consensus version supported by the module, with latest
    /// supported minor version for each
    fn supported_versions(&self) -> ModuleSupportedConsensusVersions;

    fn latest_version(&self) -> ConsensusVersion {
        let (major, minor) = self
            .supported_versions()
            .into_iter()
            .next_back()
            .expect("Must have at least one supported major version");

        ConsensusVersion::new(major, minor)
    }

    /// Create an instance of module for given arguments
    ///
    /// Note that in principle this might be called multiple times during the
    /// runtime, e.g. because the version changed.
    async fn init(
        &self,
        args: ModuleInitArgs,
    ) -> ModuleInitResult<Arc<dyn IModule + Send + Sync + 'static>>;
}

pub type DynModule = Arc<dyn IModule + Send + Sync>;

#[async_trait]
pub trait IModule: Any {
    /// Get receiver of consensus item proposals
    ///
    /// Module should set this watch channel to the current consensus
    /// items it wishes to be published.
    async fn propose_citems_rx(&self) -> watch::Receiver<Vec<CItemRaw>>;

    /// Process some consensus item
    ///
    /// If this function returns an error, it means that the transaction/citem
    /// is invalid and is ignored / should be discarded.
    ///
    /// Returns a list of effects caused by this citem
    fn process_citem(
        &self,
        dbtx: &ModuleWriteTransactionCtx,
        round: BlockRound,
        peer_pubkey: PeerPubkey,
        peer_set: &PeerSet,
        citem: &CItemRaw,
    ) -> DbTxResult<Vec<CItemEffect>, Whatever>;

    /// Process some transaction input
    ///
    /// Like [`Self::process_citem`], but for transaction inputs.
    fn process_input(
        &self,
        dbtx: &ModuleWriteTransactionCtx,
        input: &InputRaw,
    ) -> DbTxResult<Vec<CItemEffect>, Whatever>;

    /// Process some transaction input
    ///
    /// Like [`Self::process_citem`], but for transaction outputs.
    fn process_output(
        &self,
        dbtx: &ModuleWriteTransactionCtx,
        output: &OutputRaw,
    ) -> DbTxResult<Vec<CItemEffect>, Whatever>;

    /// Process all the effects generated by a processing of consensus items
    ///
    /// If this function returns an error, the whole transaction will be
    /// considered invalid, and the database transaction will NOT be
    /// committed.
    fn process_effects(
        &self,
        dbtx: &ModuleWriteTransactionCtx,
        effects: &[ModuleCItemEffect],
    ) -> DbTxResult<(), Whatever>;
}
